<?xml version="1.0"?>
<Benchmark xmlns:html="http://www.w3.org/1999/xhtml" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="product-name" resolved="false" style="SCAP_1.1" xml:lang="en-US" xsi:schemaLocation="http://checklists.nist.gov/xccdf/1.1 xccdf-1.1.4.xsd">
  <status date="2019-11-28">draft</status>
  <title>Guide to the Secure Configuration of Chromium</title>
  <description>This guide presents a catalog of security-relevant
configuration settings for Chromium. It is a rendering of
content structured in the eXtensible Configuration Checklist Description Format (XCCDF)
in order to support security automation.  The SCAP content is
is available in the <tt>scap-security-guide</tt> package which is developed at

    <html:a href="https://www.open-scap.org/security-policies/scap-security-guide">https://www.open-scap.org/security-policies/scap-security-guide</html:a>.
<br/><br/>
Providing system administrators with such guidance informs them how to securely
configure systems under their control in a variety of network roles. Policy
makers and baseline creators can use this catalog of settings, with its
associated references to higher-level security control catalogs, in order to
assist them in security baseline creation. This guide is a <em>catalog, not a
checklist</em>, and satisfaction of every item is not likely to be possible or
sensible in many operational scenarios. However, the XCCDF format enables
granular selection and adjustment of settings, and their association with OVAL
and OCIL content provides an automated checking capability. Transformations of
this document, and its associated automated checking content, are capable of
providing baselines that meet a diverse set of policy objectives. Some example
XCCDF <em>Profiles</em>, which are selections of items that form checklists and
can be used as baselines, are available with this guide. They can be
processed, in an automated fashion, with tools that support the Security
Content Automation Protocol (SCAP). The DISA STIG for Chromium,
which provides required settings for US Department of Defense systems, is
one example of a baseline created from this guidance.
</description>
  <notice id="terms_of_use">Do not attempt to implement any of the settings in
this guide without first testing them in a non-operational environment. The
creators of this guidance assume no responsibility whatsoever for its use by
other parties, and makes no guarantees, expressed or implied, about its
quality, reliability, or any other characteristic.
</notice>
  <front-matter>The SCAP Security Guide Project<br/>

    <html:a href="https://www.open-scap.org/security-policies/scap-security-guide">https://www.open-scap.org/security-policies/scap-security-guide</html:a>
</front-matter>
  <rear-matter>Red Hat and Red Hat Enterprise Linux are either registered
trademarks or trademarks of Red Hat, Inc. in the United States and other
countries. All other names are registered trademarks or trademarks of their
respective companies.
</rear-matter>
  <platform idref="cpe:/a:google:chromium-browser"/>
  <version>0.9</version>
  <metadata/>
  <Profile id="stig">
    <title override="true">Upstream STIG for Google Chromium</title>
    <description override="true">This profile is developed under the DoD consensus model and DISA FSO Vendor STIG process,
serving as the upstream development environment for the Google Chromium STIG.

As a result of the upstream/downstream relationship between the SCAP Security Guide project
and the official DISA FSO STIG baseline, users should expect variance between SSG and DISA FSO content.
For official DISA FSO STIG content, refer to https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security%2Cbrowser-guidance.

While this profile is packaged by Red Hat as part of the SCAP Security Guide package, please note
that commercial support of this SCAP content is NOT available. This profile is provided as example
SCAP content with no endorsement for suitability or production readiness. Support for this
profile is provided by the upstream SCAP Security Guide community on a best-effort basis. The
upstream project homepage is https://www.open-scap.org/security-policies/scap-security-guide/.</description>
    <select idref="chromium_policy_file" selected="true"/>
    <select idref="chromium_disable_firewall_traversal" selected="true"/>
    <select idref="chromium_block_desktop_notifications" selected="true"/>
    <select idref="chromium_disable_popups" selected="true"/>
    <select idref="chromium_disallow_location_tracking" selected="true"/>
    <select idref="chromium_blacklist_extension_installation" selected="true"/>
    <select idref="chromium_extension_whitelist" selected="true"/>
    <select idref="chromium_default_search_provider_name" selected="true"/>
    <select idref="chromium_enable_encrypted_searching" selected="true"/>
    <select idref="chromium_default_search_provider" selected="true"/>
    <select idref="chromium_disable_cleartext_passwords" selected="true"/>
    <select idref="chromium_disable_password_manager" selected="true"/>
    <select idref="chromium_http_authentication" selected="true"/>
    <select idref="chromium_disable_outdated_plugins" selected="true"/>
    <select idref="chromium_plugins_require_authorization" selected="true"/>
    <select idref="chromium_disable_thirdparty_cookies" selected="true"/>
    <select idref="chromium_disable_background_processing" selected="true"/>
    <select idref="chromium_disable_3d_graphics_api" selected="true"/>
    <select idref="chromium_disable_google_sync" selected="true"/>
    <select idref="chromium_disable_protocol_schemas" selected="true"/>
    <select idref="chromium_disable_autocomplete" selected="true"/>
    <select idref="chromium_disable_cloud_print_sharing" selected="true"/>
    <select idref="chromium_disable_network_prediction" selected="true"/>
    <select idref="chromium_disable_metrics_reporting" selected="true"/>
    <select idref="chromium_disable_search_suggestions" selected="true"/>
    <select idref="chromium_disable_saved_passwords" selected="true"/>
    <select idref="chromium_disable_incognito_mode" selected="true"/>
    <select idref="chromium_disable_plugin_blacklist" selected="true"/>
    <select idref="chromium_enable_approved_plugins" selected="true"/>
    <select idref="chromium_disable_automatic_installation" selected="true"/>
    <select idref="chromium_check_cert_revocation" selected="true"/>
    <select idref="chromium_enable_safe_browsing" selected="true"/>
    <select idref="chromium_enable_browser_history" selected="true"/>
    <select idref="chromium_default_block_plugins" selected="true"/>
    <select idref="chromium_disable_session_cookies" selected="true"/>
    <select idref="chromium_trusted_home_page" selected="true"/>
    <select idref="chromium_whitelist_plugin_urls" selected="true"/>
    <refine-value idref="var_url_blacklist" selector="javascript"/>
    <refine-value idref="var_trusted_home_page" selector="blank"/>
    <refine-value idref="var_extension_whitelist" selector="none"/>
    <refine-value idref="var_default_search_provider_name" selector="google"/>
    <refine-value idref="var_auth_schema" selector="negotiate"/>
    <refine-value idref="var_enable_encrypted_searching" selector="google"/>
  </Profile>
  <Value id="conditional_clause" type="string">
    <title>A conditional clause for check statements.</title>
    <description>A conditional clause for check statements.</description>
    <value selector="">This is a placeholder</value>
  </Value>
  <Group id="remediation_functions">
    <title>Remediation functions used by the SCAP Security Guide Project</title>
    <description>XCCDF form of the various remediation functions as used by remediation scripts from the SCAP Security Guide Project.</description>
    <Value hidden="true" id="function_create_audit_remediation_unsuccessful_file_modification_detailed" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function create_audit_remediation_unsuccessful_file_modification_detailed</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector="">function create_audit_remediation_unsuccessful_file_modification_detailed {
	mkdir -p "$(dirname "$1")"
	# The - option to mark a here document limit string (&lt;&lt;-EOF) suppresses leading tabs (but not spaces) in the output.
	cat &lt;&lt;-EOF &gt; "$1"
		## This content is a section of an Audit config snapshot recommended for RHEL8 sytems that target OSPP compliance.
		## The following content has been retreived on 2019-03-11 from: https://github.com/linux-audit/audit-userspace/blob/master/rules/30-ospp-v42.rules

		## The purpose of these rules is to meet the requirements for Operating
		## System Protection Profile (OSPP)v4.2. These rules depends on having
		## 10-base-config.rules, 11-loginuid.rules, and 43-module-load.rules installed.

		## Unsuccessful file creation (open with O_CREAT)
		-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
		-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create

		## Unsuccessful file modifications (open for write or truncate)
		-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
		-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification

		## Unsuccessful file access (any other opens) This has to go last.
		-a always,exit -F arch=b32 -S open,creat,truncate,ftruncate,openat,open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
		-a always,exit -F arch=b64 -S open,creat,truncate,ftruncate,openat,open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
		-a always,exit -F arch=b32 -S open,creat,truncate,ftruncate,openat,open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
		-a always,exit -F arch=b64 -S open,creat,truncate,ftruncate,openat,open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
	EOF
}</value>
    </Value>
    <Value hidden="true" id="function_die" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function die</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># Print a message to stderr and exit the shell
# $1: The message to print.
# $2: The error code (optional, default is 1)
function die {
	local _message="$1" _rc="${2:-1}"
	printf '%s\n' "$_message" &gt;&amp;2
	exit "$_rc"
}</value>
    </Value>
    <Value hidden="true" id="function_ensure_there_are_servers_in_ntp_compatible_config_file" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function ensure_there_are_servers_in_ntp_compatible_config_file</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># Function ensures that the ntp/chrony config file contains valid server entries
# $1: Path to the config file
# $2: Comma-separated list of servers
function ensure_there_are_servers_in_ntp_compatible_config_file {
	# If invoked with no arguments, exit. This is an intentional behavior.
	[ $# -gt 1 ] || return 0
	[ $# = 2 ] || die "$0 requires zero or exactly two arguments"
	local _config_file="$1" _servers_list="$2"
	if ! grep -q '#[[:space:]]*server' "$_config_file"; then
		for server in $(echo "$_servers_list" | tr ',' '\n') ; do
			printf '\nserver %s iburst' "$server" &gt;&gt; "$_config_file"
		done
	else
		sed -i 's/#[ \t]*server/server/g' "$_config_file"
	fi
}</value>
    </Value>
    <Value hidden="true" id="function_fix_audit_syscall_rule" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function fix_audit_syscall_rule</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># Function to fix syscall audit rule for given system call. It is
# based on example audit syscall rule definitions as outlined in
# /usr/share/doc/audit-2.3.7/stig.rules file provided with the audit
# package. It will combine multiple system calls belonging to the same
# syscall group into one audit rule (rather than to create audit rule per
# different system call) to avoid audit infrastructure performance penalty
# in the case of 'one-audit-rule-definition-per-one-system-call'. See:
#
#   https://www.redhat.com/archives/linux-audit/2014-November/msg00009.html
#
# for further details.
#
# Expects five arguments (each of them is required) in the form of:
# * audit tool				tool used to load audit rules,
# 					either 'auditctl', or 'augenrules
# * audit rules' pattern		audit rule skeleton for same syscall
# * syscall group			greatest common string this rule shares
# 					with other rules from the same group
# * architecture			architecture this rule is intended for
# * full form of new rule to add	expected full form of audit rule as to be
# 					added into audit.rules file
#
# Note: The 2-th up to 4-th arguments are used to determine how many existing
# audit rules will be inspected for resemblance with the new audit rule
# (5-th argument) the function is going to add. The rule's similarity check
# is performed to optimize audit.rules definition (merge syscalls of the same
# group into one rule) to avoid the "single-syscall-per-audit-rule" performance
# penalty.
#
# Example call:
#
#	See e.g. 'audit_rules_file_deletion_events.sh' remediation script
#
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
	echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
	echo "Aborting."
	exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
# 
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

retval=0

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
	echo "Unknown audit rules loading tool: $1. Aborting."
	echo "Use either 'auditctl' or 'augenrules'!"
	return 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
	files_to_inspect+=('/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
	# Extract audit $key from audit rule so we can use it later
	key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)' '|' "$full_rule" : '.*-F[[:space:]]key=\([^[:space:]]\+\)')
	readarray -t matches &lt; &lt;(sed -s -n -e "\;${pattern};!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules)
	if [ $? -ne 0 ]
	then
		retval=1
	fi
	for match in "${matches[@]}"
	do
		files_to_inspect+=("${match}")
	done
	# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
	if [ ${#files_to_inspect[@]} -eq "0" ]
	then
		file_to_inspect="/etc/audit/rules.d/$key.rules"
		files_to_inspect=("$file_to_inspect")
		if [ ! -e "$file_to_inspect" ]
		then
			touch "$file_to_inspect"
			chmod 0640 "$file_to_inspect"
		fi
	fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do
	# Filter existing $audit_file rules' definitions to select those that:
	# * follow the rule pattern, and
	# * meet the hardware architecture requirement, and
	# * are current syscall group specific
	readarray -t existing_rules &lt; &lt;(sed -e "\;${pattern};!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file")
	if [ $? -ne 0 ]
	then
		retval=1
	fi

	# Process rules found case-by-case
	for rule in "${existing_rules[@]}"
	do
		# Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
		if [ "${rule}" != "${full_rule}" ]
		then
			# If so, isolate just '(-S \w)+' substring of that rule
			rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
			# Check if list of '-S syscall' arguments of that rule is subset
			# of '-S syscall' list of expected $full_rule
			if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
			then
				# Rule is covered (i.e. the list of -S syscalls for this rule is
				# subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
				# Thus delete the rule from audit.rules &amp; our array
				sed -i -e "\;${rule};d" "$audit_file"
				if [ $? -ne 0 ]
				then
					retval=1
				fi
				existing_rules=("${existing_rules[@]//$rule/}")
			else
				# Rule isn't covered by $full_rule - it besides -S syscall arguments
				# for this group contains also -S syscall arguments for other syscall
				# group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
				# since 'lchown' &amp; 'fchownat' share 'chown' substring
				# Therefore:
				# * 1) delete the original rule from audit.rules
				# (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
				# * 2) delete the -S syscall arguments for this syscall group, but
				# keep those not belonging to this syscall group
				# (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
				# * 3) append the modified (filtered) rule again into audit.rules
				# if the same rule not already present
				#
				# 1) Delete the original rule
				sed -i -e "\;${rule};d" "$audit_file"
				if [ $? -ne 0 ]
				then
					retval=1
				fi

				# 2) Delete syscalls for this group, but keep those from other groups
				# Convert current rule syscall's string into array splitting by '-S' delimiter
				IFS_BKP="$IFS"
				IFS=$'-S'
				read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
				# Reset IFS back to default
				IFS="$IFS_BKP"
				# Splitting by "-S" can't be replaced by the readarray functionality easily

				# Declare new empty string to hold '-S syscall' arguments from other groups
				new_syscalls_for_rule=''
				# Walk through existing '-S syscall' arguments
				for syscall_arg in "${rule_syscalls_as_array[@]}"
				do
					# Skip empty $syscall_arg values
					if [ "$syscall_arg" == '' ]
					then
						continue
					fi
					# If the '-S syscall' doesn't belong to current group add it to the new list
					# (together with adding '-S' delimiter back for each of such item found)
					if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
					then
						new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
					fi
				done
				# Replace original '-S syscall' list with the new one for this rule
				updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
				# Squeeze repeated whitespace characters in rule definition (if any) into one
				updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
				# 3) Append the modified / filtered rule again into audit.rules
				#    (but only in case it's not present yet to prevent duplicate definitions)
				if ! grep -q -- "$updated_rule" "$audit_file"
				then
					echo "$updated_rule" &gt;&gt; "$audit_file"
				fi
			fi
		else
			# $audit_file already contains the expected rule form for this
			# architecture &amp; key =&gt; don't insert it second time
			append_expected_rule=1
		fi
	done

	# We deleted all rules that were subset of the expected one for this arch &amp; key.
	# Also isolated rules containing system calls not from this system calls group.
	# Now append the expected rule if it's not present in $audit_file yet
	if [[ ${append_expected_rule} -eq "0" ]]
	then
		echo "$full_rule" &gt;&gt; "$audit_file"
	fi
done

return $retval

}</value>
    </Value>
    <Value hidden="true" id="function_fix_audit_watch_rule" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function fix_audit_watch_rule</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># Function to fix audit file system object watch rule for given path:
# * if rule exists, also verifies the -w bits match the requirements
# * if rule doesn't exist yet, appends expected rule form to $files_to_inspect
#   audit rules file, depending on the tool which was used to load audit rules
#
# Expects four arguments (each of them is required) in the form of:
# * audit tool				tool used to load audit rules,
# 					either 'auditctl', or 'augenrules'
# * path                        	value of -w audit rule's argument
# * required access bits        	value of -p audit rule's argument
# * key                         	value of -k audit rule's argument
#
# Example call:
#
#       fix_audit_watch_rule "auditctl" "/etc/localtime" "wa" "audit_time_rules"
#
function fix_audit_watch_rule {

# Load function arguments into local variables
local tool="$1"
local path="$2"
local required_access_bits="$3"
local key="$4"

# Check sanity of the input
if [ $# -ne "4" ]
then
	echo "Usage: fix_audit_watch_rule 'tool' 'path' 'bits' 'key'"
	echo "Aborting."
	exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
#
# -----------------------------------------------------------------------------------------
# Tool used to load audit rules	| Rule already defined	|  Audit rules file to inspect	  |
# -----------------------------------------------------------------------------------------
#	auditctl		|     Doesn't matter	|  /etc/audit/audit.rules	  |
# -----------------------------------------------------------------------------------------
# 	augenrules		|          Yes		|  /etc/audit/rules.d/*.rules	  |
# 	augenrules		|          No		|  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
declare -a files_to_inspect
files_to_inspect=()

# Check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
	echo "Unknown audit rules loading tool: $1. Aborting."
	echo "Use either 'auditctl' or 'augenrules'!"
	exit 1
# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# into the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
	files_to_inspect+=('/etc/audit/audit.rules')
# If the audit is 'augenrules', then check if rule is already defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.
# If rule isn't defined, add '/etc/audit/rules.d/$key.rules' to list of files for inspection.
elif [ "$tool" == 'augenrules' ]
then
	readarray -t matches &lt; &lt;(grep -P "[\s]*-w[\s]+$path" /etc/audit/rules.d/*.rules)

	# For each of the matched entries
	for match in "${matches[@]}"
	do
		# Extract filepath from the match
		rulesd_audit_file=$(echo $match | cut -f1 -d ':')
		# Append that path into list of files for inspection
		files_to_inspect+=("$rulesd_audit_file")
	done
	# Case when particular audit rule isn't defined yet
	if [ "${#files_to_inspect[@]}" -eq "0" ]
	then
		# Append '/etc/audit/rules.d/$key.rules' into list of files for inspection
		local key_rule_file="/etc/audit/rules.d/$key.rules"
		# If the $key.rules file doesn't exist yet, create it with correct permissions
		if [ ! -e "$key_rule_file" ]
		then
			touch "$key_rule_file"
			chmod 0640 "$key_rule_file"
		fi

		files_to_inspect+=("$key_rule_file")
	fi
fi

# Finally perform the inspection and possible subsequent audit rule
# correction for each of the files previously identified for inspection
for audit_rules_file in "${files_to_inspect[@]}"
do

	# Check if audit watch file system object rule for given path already present
	if grep -q -P -- "[\s]*-w[\s]+$path" "$audit_rules_file"
	then
		# Rule is found =&gt; verify yet if existing rule definition contains
		# all of the required access type bits

		# Escape slashes in path for use in sed pattern below
		local esc_path=${path//$'/'/$'\/'}
		# Define BRE whitespace class shortcut
		local sp="[[:space:]]"
		# Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule
		current_access_bits=$(sed -ne "s/$sp*-w$sp\+$esc_path$sp\+-p$sp\+\([rxwa]\{1,4\}\).*/\1/p" "$audit_rules_file")
		# Split required access bits string into characters array
		# (to check bit's presence for one bit at a time)
		for access_bit in $(echo "$required_access_bits" | grep -o .)
		do
			# For each from the required access bits (e.g. 'w', 'a') check
			# if they are already present in current access bits for rule.
			# If not, append that bit at the end
			if ! grep -q "$access_bit" &lt;&lt;&lt; "$current_access_bits"
			then
				# Concatenate the existing mask with the missing bit
				current_access_bits="$current_access_bits$access_bit"
			fi
		done
		# Propagate the updated rule's access bits (original + the required
		# ones) back into the /etc/audit/audit.rules file for that rule
		sed -i "s/\($sp*-w$sp\+$esc_path$sp\+-p$sp\+\)\([rxwa]\{1,4\}\)\(.*\)/\1$current_access_bits\3/" "$audit_rules_file"
	else
		# Rule isn't present yet. Append it at the end of $audit_rules_file file
		# with proper key

		echo "-w $path -p $required_access_bits -k $key" &gt;&gt; "$audit_rules_file"
	fi
done
}</value>
    </Value>
    <Value hidden="true" id="function_include_merge_files_by_lines" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function include_merge_files_by_lines</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector="">function include_merge_files_by_lines {
	:
}

# 1: Filename of the "master" file
# 2: Filename of the newly created file
function create_empty_file_like {
	local lines_count
	lines_count=$(cat "$1" | wc -l)
	for _ in $(seq 1 "$lines_count"); do
		printf '\n' &gt;&gt; "$2"
	done
}


# 1: Filename of the "master" file
# 2: Filename of sample flie
function second_file_is_same_except_newlines {
	local lines_of_master lines_of_sample len_of_master line_number i
	readarray -t lines_of_master &lt; "$1"
	readarray -t lines_of_sample &lt; "$2"

	len_of_master="${#lines_of_master[@]}"
	if test "$len_of_master" != "${#lines_of_sample[@]}"; then
		echo "Files '$1' and '$2' have different number of lines, $len_of_master and ${#lines_of_sample[@]} respectively."
		return 1
	fi

	for line_number in $(seq 1 "$len_of_master"); do
		i=$((line_number - 1))
		test -n "${lines_of_sample[$i]}" || continue
		if test "${lines_of_master[$i]}" != "${lines_of_sample[$i]}"; then
			echo "Line $line_number is different in files '$1' and '$2'."
			return 1
		fi
	done
}


# 1: Filename of the "master" file
# 2: Filename of sample flie
# 3: List of indices (1-based, space-separated string)
function merge_first_lines_to_second_on_indices {
	local lines_of_master lines_of_sample line_number i
	test -f "$2" || create_empty_file_like "$1" "$2"

	readarray -t lines_of_master &lt; "$1"
	readarray -t lines_of_sample &lt; "$2"

	error_msg="$(second_file_is_same_except_newlines "$1" "$2")"
	if test $? != 0; then
		echo "Error merging lines into '$2': $error_msg" &gt;&amp;2
		return 1
	fi

	for line_number in $3; do
		i=$((line_number - 1))
		lines_of_sample[$i]="${lines_of_master[$i]}"
	done

	printf "%s\n" "${lines_of_sample[@]}" &gt; "$2"
}</value>
    </Value>
    <Value hidden="true" id="function_include_mount_options_functions" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function include_mount_options_functions</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector="">function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points &lt; &lt;(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] &amp;&amp; _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" &gt;&gt; /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" &gt;&amp;2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}</value>
    </Value>
    <Value hidden="true" id="function_include_set_faillock_option" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function include_set_faillock_option</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector="">function include_set_faillock_option {
	:
}

function insert_preauth {
	local pam_file="$1"
	local option="$2"
	local value="$3"
	# is auth required pam_faillock.so preauth present?
	if grep -qE "^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*$" "$pam_file" ; then
		# is the option set?
		if grep -qE "^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*$option=([0-9]*).*$" "$pam_file" ; then
			# just change the value of option to a correct value
			sed -i --follow-symlinks "s/\(^auth.*required.*pam_faillock.so.*preauth.*silent.*\)\($option *= *\).*/\1\2$value/" "$pam_file"
		# the option is not set.
		else
			# append the option
			sed -i --follow-symlinks "/^auth.*required.*pam_faillock.so.*preauth.*silent.*/ s/$/ $option=$value/" "$pam_file"
		fi
	# auth required pam_faillock.so preauth is not present, insert the whole line
	else
		sed -i --follow-symlinks "/^auth.*sufficient.*pam_unix.so.*/i auth        required      pam_faillock.so preauth silent $option=$value" "$pam_file"
	fi
}

function insert_authfail {
	local pam_file="$1"
	local option="$2"
	local value="$3"
	# is auth default pam_faillock.so authfail present?
	if grep -qE "^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*$" "$pam_file" ; then
		# is the option set?
		if grep -qE "^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*$option=([0-9]*).*$" "$pam_file" ; then
			# just change the value of option to a correct value
			sed -i --follow-symlinks "s/\(^auth.*[default=die].*pam_faillock.so.*authfail.*\)\($option *= *\).*/\1\2$value/" "$pam_file"
		# the option is not set.
		else
			# append the option
			sed -i --follow-symlinks "/^auth.*[default=die].*pam_faillock.so.*authfail.*/ s/$/ $option=$value/" "$pam_file"
		fi
	# auth default pam_faillock.so authfail is not present, insert the whole line
	else
		sed -i --follow-symlinks "/^auth.*sufficient.*pam_unix.so.*/a auth        [default=die] pam_faillock.so authfail $option=$value" "$pam_file"
	fi
}

function insert_account {
	local pam_file="$1"
	if ! grep -qE "^\s*account\s+required\s+pam_faillock\.so.*$" "$pam_file" ; then
		sed -E -i --follow-symlinks "/^\s*account\s*required\s*pam_unix.so/i account     required      pam_faillock.so" "$pam_file"
	fi
}

function set_faillock_option {
	local pam_file="$1"
	local option="$2"
	local value="$3"
	insert_preauth "$pam_file" "$option" "$value"
	insert_authfail "$pam_file" "$option" "$value"
	insert_account "$pam_file"
}</value>
    </Value>
    <Value hidden="true" id="function_perform_audit_adjtimex_settimeofday_stime_remediation" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function perform_audit_adjtimex_settimeofday_stime_remediation</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># Function to fix syscall audit rule for given system call. It is
# based on example audit syscall rule definitions as outlined in
# /usr/share/doc/audit-2.3.7/stig.rules file provided with the audit
# package. It will combine multiple system calls belonging to the same
# syscall group into one audit rule (rather than to create audit rule per
# different system call) to avoid audit infrastructure performance penalty
# in the case of 'one-audit-rule-definition-per-one-system-call'. See:
#
#   https://www.redhat.com/archives/linux-audit/2014-November/msg00009.html
#
# for further details.
#
# Expects five arguments (each of them is required) in the form of:
# * audit tool				tool used to load audit rules,
# 					either 'auditctl', or 'augenrules
# * audit rules' pattern		audit rule skeleton for same syscall
# * syscall group			greatest common string this rule shares
# 					with other rules from the same group
# * architecture			architecture this rule is intended for
# * full form of new rule to add	expected full form of audit rule as to be
# 					added into audit.rules file
#
# Note: The 2-th up to 4-th arguments are used to determine how many existing
# audit rules will be inspected for resemblance with the new audit rule
# (5-th argument) the function is going to add. The rule's similarity check
# is performed to optimize audit.rules definition (merge syscalls of the same
# group into one rule) to avoid the "single-syscall-per-audit-rule" performance
# penalty.
#
# Example call:
#
#	See e.g. 'audit_rules_file_deletion_events.sh' remediation script
#
function fix_audit_syscall_rule {

# Load function arguments into local variables
local tool="$1"
local pattern="$2"
local group="$3"
local arch="$4"
local full_rule="$5"

# Check sanity of the input
if [ $# -ne "5" ]
then
	echo "Usage: fix_audit_syscall_rule 'tool' 'pattern' 'group' 'arch' 'full rule'"
	echo "Aborting."
	exit 1
fi

# Create a list of audit *.rules files that should be inspected for presence and correctness
# of a particular audit rule. The scheme is as follows:
# 
# -----------------------------------------------------------------------------------------
#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |
# -----------------------------------------------------------------------------------------
#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |
# -----------------------------------------------------------------------------------------
#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |
#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |
# -----------------------------------------------------------------------------------------
#
declare -a files_to_inspect

retval=0

# First check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
	echo "Unknown audit rules loading tool: $1. Aborting."
	echo "Use either 'auditctl' or 'augenrules'!"
	return 1
# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'
# file to the list of files to be inspected
elif [ "$tool" == 'auditctl' ]
then
	files_to_inspect+=('/etc/audit/audit.rules' )
# If audit tool is 'augenrules', then check if the audit rule is defined
# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection
# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection
elif [ "$tool" == 'augenrules' ]
then
	# Extract audit $key from audit rule so we can use it later
	key=$(expr "$full_rule" : '.*-k[[:space:]]\([^[:space:]]\+\)' '|' "$full_rule" : '.*-F[[:space:]]key=\([^[:space:]]\+\)')
	readarray -t matches &lt; &lt;(sed -s -n -e "\;${pattern};!d" -e "/${arch}/!d" -e "/${group}/!d;F" /etc/audit/rules.d/*.rules)
	if [ $? -ne 0 ]
	then
		retval=1
	fi
	for match in "${matches[@]}"
	do
		files_to_inspect+=("${match}")
	done
	# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet
	if [ ${#files_to_inspect[@]} -eq "0" ]
	then
		file_to_inspect="/etc/audit/rules.d/$key.rules"
		files_to_inspect=("$file_to_inspect")
		if [ ! -e "$file_to_inspect" ]
		then
			touch "$file_to_inspect"
			chmod 0640 "$file_to_inspect"
		fi
	fi
fi

#
# Indicator that we want to append $full_rule into $audit_file by default
local append_expected_rule=0

for audit_file in "${files_to_inspect[@]}"
do
	# Filter existing $audit_file rules' definitions to select those that:
	# * follow the rule pattern, and
	# * meet the hardware architecture requirement, and
	# * are current syscall group specific
	readarray -t existing_rules &lt; &lt;(sed -e "\;${pattern};!d" -e "/${arch}/!d" -e "/${group}/!d"  "$audit_file")
	if [ $? -ne 0 ]
	then
		retval=1
	fi

	# Process rules found case-by-case
	for rule in "${existing_rules[@]}"
	do
		# Found rule is for same arch &amp; key, but differs (e.g. in count of -S arguments)
		if [ "${rule}" != "${full_rule}" ]
		then
			# If so, isolate just '(-S \w)+' substring of that rule
			rule_syscalls=$(echo $rule | grep -o -P '(-S \w+ )+')
			# Check if list of '-S syscall' arguments of that rule is subset
			# of '-S syscall' list of expected $full_rule
			if grep -q -- "$rule_syscalls" &lt;&lt;&lt; "$full_rule"
			then
				# Rule is covered (i.e. the list of -S syscalls for this rule is
				# subset of -S syscalls of $full_rule =&gt; existing rule can be deleted
				# Thus delete the rule from audit.rules &amp; our array
				sed -i -e "\;${rule};d" "$audit_file"
				if [ $? -ne 0 ]
				then
					retval=1
				fi
				existing_rules=("${existing_rules[@]//$rule/}")
			else
				# Rule isn't covered by $full_rule - it besides -S syscall arguments
				# for this group contains also -S syscall arguments for other syscall
				# group. Example: '-S lchown -S fchmod -S fchownat' =&gt; group='chown'
				# since 'lchown' &amp; 'fchownat' share 'chown' substring
				# Therefore:
				# * 1) delete the original rule from audit.rules
				# (original '-S lchown -S fchmod -S fchownat' rule would be deleted)
				# * 2) delete the -S syscall arguments for this syscall group, but
				# keep those not belonging to this syscall group
				# (original '-S lchown -S fchmod -S fchownat' would become '-S fchmod'
				# * 3) append the modified (filtered) rule again into audit.rules
				# if the same rule not already present
				#
				# 1) Delete the original rule
				sed -i -e "\;${rule};d" "$audit_file"
				if [ $? -ne 0 ]
				then
					retval=1
				fi

				# 2) Delete syscalls for this group, but keep those from other groups
				# Convert current rule syscall's string into array splitting by '-S' delimiter
				IFS_BKP="$IFS"
				IFS=$'-S'
				read -a rule_syscalls_as_array &lt;&lt;&lt; "$rule_syscalls"
				# Reset IFS back to default
				IFS="$IFS_BKP"
				# Splitting by "-S" can't be replaced by the readarray functionality easily

				# Declare new empty string to hold '-S syscall' arguments from other groups
				new_syscalls_for_rule=''
				# Walk through existing '-S syscall' arguments
				for syscall_arg in "${rule_syscalls_as_array[@]}"
				do
					# Skip empty $syscall_arg values
					if [ "$syscall_arg" == '' ]
					then
						continue
					fi
					# If the '-S syscall' doesn't belong to current group add it to the new list
					# (together with adding '-S' delimiter back for each of such item found)
					if grep -q -v -- "$group" &lt;&lt;&lt; "$syscall_arg"
					then
						new_syscalls_for_rule="$new_syscalls_for_rule -S $syscall_arg"
					fi
				done
				# Replace original '-S syscall' list with the new one for this rule
				updated_rule=${rule//$rule_syscalls/$new_syscalls_for_rule}
				# Squeeze repeated whitespace characters in rule definition (if any) into one
				updated_rule=$(echo "$updated_rule" | tr -s '[:space:]')
				# 3) Append the modified / filtered rule again into audit.rules
				#    (but only in case it's not present yet to prevent duplicate definitions)
				if ! grep -q -- "$updated_rule" "$audit_file"
				then
					echo "$updated_rule" &gt;&gt; "$audit_file"
				fi
			fi
		else
			# $audit_file already contains the expected rule form for this
			# architecture &amp; key =&gt; don't insert it second time
			append_expected_rule=1
		fi
	done

	# We deleted all rules that were subset of the expected one for this arch &amp; key.
	# Also isolated rules containing system calls not from this system calls group.
	# Now append the expected rule if it's not present in $audit_file yet
	if [[ ${append_expected_rule} -eq "0" ]]
	then
		echo "$full_rule" &gt;&gt; "$audit_file"
	fi
done

return $retval

}


# Function to perform remediation for the 'adjtimex', 'settimeofday', and 'stime' audit
# system calls on RHEL, Fedora or OL systems.
# Remediation performed for both possible tools: 'auditctl' and 'augenrules'.
#
# Note: 'stime' system call isn't known at 64-bit arch (see "$ ausyscall x86_64 stime" 's output)
# therefore excluded from the list of time group system calls to be audited on this arch
#
# Example Call:
#
#      perform_audit_adjtimex_settimeofday_stime_remediation
#
function perform_audit_adjtimex_settimeofday_stime_remediation {

# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do

	PATTERN="-a always,exit -F arch=${ARCH} -S .* -k *"
	# Create expected audit group and audit rule form for particular system call &amp; architecture
	if [ ${ARCH} = "b32" ]
	then
		# stime system call is known at 32-bit arch (see e.g "$ ausyscall i386 stime" 's output)
		# so append it to the list of time group system calls to be audited
		GROUP="\(adjtimex\|settimeofday\|stime\)"
		FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -S stime -k audit_time_rules"
	elif [ ${ARCH} = "b64" ]
	then
		# stime system call isn't known at 64-bit arch (see "$ ausyscall x86_64 stime" 's output)
		# therefore don't add it to the list of time group system calls to be audited
		GROUP="\(adjtimex\|settimeofday\)"
		FULL_RULE="-a always,exit -F arch=${ARCH} -S adjtimex -S settimeofday -k audit_time_rules"
	fi
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

}</value>
    </Value>
    <Value hidden="true" id="function_perform_audit_rules_privileged_commands_remediation" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function perform_audit_rules_privileged_commands_remediation</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># Function to perform remediation for 'audit_rules_privileged_commands' rule
#
# Expects two arguments:
#
# audit_tool		tool used to load audit rules
# 			One of 'auditctl' or 'augenrules'
#
# min_auid		Minimum original ID the user logged in with
# 			'500' for RHEL-6 and before, '1000' for RHEL-7 and after.
#
# Example Call(s):
#
#      perform_audit_rules_privileged_commands_remediation "auditctl" "500"
#      perform_audit_rules_privileged_commands_remediation "augenrules"	"1000"
#
function perform_audit_rules_privileged_commands_remediation {
#
# Load function arguments into local variables
local tool="$1"
local min_auid="$2"

# Check sanity of the input
if [ $# -ne "2" ]
then
	echo "Usage: perform_audit_rules_privileged_commands_remediation 'auditctl | augenrules' '500 | 1000'"
	echo "Aborting."
	exit 1
fi

declare -a files_to_inspect=()

# Check sanity of the specified audit tool
if [ "$tool" != 'auditctl' ] &amp;&amp; [ "$tool" != 'augenrules' ]
then
	echo "Unknown audit rules loading tool: $1. Aborting."
	echo "Use either 'auditctl' or 'augenrules'!"
	exit 1
# If the audit tool is 'auditctl', then:
# * add '/etc/audit/audit.rules'to the list of files to be inspected,
# * specify '/etc/audit/audit.rules' as the output audit file, where
#   missing rules should be inserted
elif [ "$tool" == 'auditctl' ]
then
	files_to_inspect=("/etc/audit/audit.rules")
	output_audit_file="/etc/audit/audit.rules"
#
# If the audit tool is 'augenrules', then:
# * add '/etc/audit/rules.d/*.rules' to the list of files to be inspected
#   (split by newline),
# * specify /etc/audit/rules.d/privileged.rules' as the output file, where
#   missing rules should be inserted
elif [ "$tool" == 'augenrules' ]
then
	readarray -t files_to_inspect &lt; &lt;(find /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -print)
	output_audit_file="/etc/audit/rules.d/privileged.rules"
fi

# Obtain the list of SUID/SGID binaries on the particular system (split by newline)
# into privileged_binaries array
readarray -t privileged_binaries &lt; &lt;(find / -xdev -type f -perm -4000 -o -type f -perm -2000 2&gt;/dev/null)

# Keep list of SUID/SGID binaries that have been already handled within some previous iteration
declare -a sbinaries_to_skip=()

# For each found sbinary in privileged_binaries list
for sbinary in "${privileged_binaries[@]}"
do

	# Check if this sbinary wasn't already handled in some of the previous sbinary iterations
	# Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)
	if [[ $(sed -ne "\|${sbinary}|p" &lt;&lt;&lt; "${sbinaries_to_skip[*]}") ]]
	then
		# If so, don't process it second time &amp; go to process next sbinary
		continue
	fi

	# Reset the counter of inspected files when starting to check
	# presence of existing audit rule for new sbinary
	local count_of_inspected_files=0

	# Define expected rule form for this binary
	expected_rule="-a always,exit -F path=${sbinary} -F perm=x -F auid&gt;=${min_auid} -F auid!=unset -k privileged"

	# If list of audit rules files to be inspected is empty, just add new rule and move on to next binary
	if [[ ${#files_to_inspect[@]} -eq 0 ]]; then
		echo "$expected_rule" &gt;&gt; "$output_audit_file"
		continue
	fi

	# Replace possible slash '/' character in sbinary definition so we could use it in sed expressions below
	sbinary_esc=${sbinary//$'/'/$'\/'}

	# For each audit rules file from the list of files to be inspected
	for afile in "${files_to_inspect[@]}"
	do

		# Search current audit rules file's content for match. Match criteria:
		# * existing rule is for the same SUID/SGID binary we are currently processing (but
		#   can contain multiple -F path= elements covering multiple SUID/SGID binaries)
		# * existing rule contains all arguments from expected rule form (though can contain
		#   them in arbitrary order)
	
		base_search=$(sed -e '/-a always,exit/!d' -e '/-F path='"${sbinary_esc}"'/!d'		\
				-e '/-F path=[^[:space:]]\+/!d'   -e '/-F perm=.*/!d'						\
				-e '/-F auid&gt;='"${min_auid}"'/!d' -e '/-F auid!=\(4294967295\|unset\)/!d'	\
				-e '/-k \|-F key=/!d' "$afile")

		# Increase the count of inspected files for this sbinary
		count_of_inspected_files=$((count_of_inspected_files + 1))

		# Require execute access type to be set for existing audit rule
		exec_access='x'

		# Search current audit rules file's content for presence of rule pattern for this sbinary
		if [[ $base_search ]]
		then

			# Current audit rules file already contains rule for this binary =&gt;
			# Store the exact form of found rule for this binary for further processing
			concrete_rule=$base_search

			# Select all other SUID/SGID binaries possibly also present in the found rule

			readarray -t handled_sbinaries &lt; &lt;(grep -o -e "-F path=[^[:space:]]\+" &lt;&lt;&lt; "$concrete_rule")
			handled_sbinaries=("${handled_sbinaries[@]//-F path=/}")

			# Merge the list of such SUID/SGID binaries found in this iteration with global list ignoring duplicates
			readarray -t sbinaries_to_skip &lt; &lt;(for i in "${sbinaries_to_skip[@]}" "${handled_sbinaries[@]}"; do echo "$i"; done | sort -du)

			# Separate concrete_rule into three sections using hash '#'
			# sign as a delimiter around rule's permission section borders
			concrete_rule="$(echo "$concrete_rule" | sed -n "s/\(.*\)\+\(-F perm=[rwax]\+\)\+/\1#\2#/p")"

			# Split concrete_rule into head, perm, and tail sections using hash '#' delimiter

			rule_head=$(cut -d '#' -f 1 &lt;&lt;&lt; "$concrete_rule")
			rule_perm=$(cut -d '#' -f 2 &lt;&lt;&lt; "$concrete_rule")
			rule_tail=$(cut -d '#' -f 3 &lt;&lt;&lt; "$concrete_rule")

			# Extract already present exact access type [r|w|x|a] from rule's permission section
			access_type=${rule_perm//-F perm=/}

			# Verify current permission access type(s) for rule contain 'x' (execute) permission
			if ! grep -q "$exec_access" &lt;&lt;&lt; "$access_type"
			then

				# If not, append the 'x' (execute) permission to the existing access type bits
				access_type="$access_type$exec_access"
				# Reconstruct the permissions section for the rule
				new_rule_perm="-F perm=$access_type"
				# Update existing rule in current audit rules file with the new permission section
				sed -i "s#${rule_head}\(.*\)${rule_tail}#${rule_head}${new_rule_perm}${rule_tail}#" "$afile"

			fi

		# If the required audit rule for particular sbinary wasn't found yet, insert it under following conditions:
		#
		# * in the "auditctl" mode of operation insert particular rule each time
		#   (because in this mode there's only one file -- /etc/audit/audit.rules to be inspected for presence of this rule),
		#
		# * in the "augenrules" mode of operation insert particular rule only once and only in case we have already
		#   searched all of the files from /etc/audit/rules.d/*.rules location (since that audit rule can be defined
		#   in any of those files and if not, we want it to be inserted only once into /etc/audit/rules.d/privileged.rules file)
		#
		elif [ "$tool" == "auditctl" ] || [[ "$tool" == "augenrules" &amp;&amp; $count_of_inspected_files -eq "${#files_to_inspect[@]}" ]]
		then

			# Check if this sbinary wasn't already handled in some of the previous afile iterations
			# Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)
			if [[ ! $(sed -ne "\|${sbinary}|p" &lt;&lt;&lt; "${sbinaries_to_skip[*]}") ]]
			then
				# Current audit rules file's content doesn't contain expected rule for this
				# SUID/SGID binary yet =&gt; append it
				echo "$expected_rule" &gt;&gt; "$output_audit_file"
			fi

			continue
		fi

	done

done
}</value>
    </Value>
    <Value hidden="true" id="function_populate" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function populate</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># The populate function isn't directly used by SSG at the moment but it can be 
# used for testing purposes and will be used in SSG Testsuite in the future.

function populate {
# code to populate environment variables needed (for unit testing)
if [ -z "${!1}" ]; then
	echo "$1 is not defined. Exiting."
	exit
fi
}</value>
    </Value>
    <Value hidden="true" id="function_replace_or_append" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function replace_or_append</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector=""># Function to replace configuration setting in config file or add the configuration setting if
# it does not exist.
#
# Expects arguments:
#
# config_file:		Configuration file that will be modified
# key:			Configuration option to change
# value:		Value of the configuration option to change
# cce:			The CCE identifier or '@CCENUM@' if no CCE identifier exists
# format:		The printf-like format string that will be given stripped key and value as arguments,
#			so e.g. '%s=%s' will result in key=value subsitution (i.e. without spaces around =)
#
# Optional arugments:
#
# format:		Optional argument to specify the format of how key/value should be
# 			modified/appended in the configuration file. The default is key = value.
#
# Example Call(s):
#
#     With default format of 'key = value':
#     replace_or_append '/etc/sysctl.conf' '^kernel.randomize_va_space' '2' '@CCENUM@'
#
#     With custom key/value format:
#     replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' 'disabled' '@CCENUM@' '%s=%s'
#
#     With a variable:
#     replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' $var_selinux_state '@CCENUM@' '%s=%s'
#
function replace_or_append {
  local default_format='%s = %s' case_insensitive_mode=yes sed_case_insensitive_option='' grep_case_insensitive_option=''
  local config_file=$1
  local key=$2
  local value=$3
  local cce=$4
  local format=$5

  if [ "$case_insensitive_mode" = yes ]; then
    sed_case_insensitive_option="i"
    grep_case_insensitive_option="-i"
  fi
  [ -n "$format" ] || format="$default_format"
  # Check sanity of the input
  [ $# -ge "3" ] || { echo "Usage: replace_or_append &lt;config_file_location&gt; &lt;key_to_search&gt; &lt;new_value&gt; [&lt;CCE number or literal '@CCENUM@' if unknown&gt;] [printf-like format, default is '$default_format']" &gt;&amp;2; exit 1; }

  # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.
  # Otherwise, regular sed command will do.
  sed_command=('sed' '-i')
  if test -L "$config_file"; then
    sed_command+=('--follow-symlinks')
  fi

  # Test that the cce arg is not empty or does not equal @CCENUM@.
  # If @CCENUM@ exists, it means that there is no CCE assigned.
  if [ -n "$cce" ] &amp;&amp; [ "$cce" != '@CCENUM@' ]; then
    cce="${cce}"
  else
    cce="CCE"
  fi

  # Strip any search characters in the key arg so that the key can be replaced without
  # adding any search characters to the config file.
  stripped_key=$(sed 's/[\^=\$,;+]*//g' &lt;&lt;&lt; "$key")

  # shellcheck disable=SC2059
  printf -v formatted_output "$format" "$stripped_key" "$value"

  # If the key exists, change it. Otherwise, add it to the config_file.
  # We search for the key string followed by a word boundary (matched by \&gt;),
  # so if we search for 'setting', 'setting2' won't match.
  if LC_ALL=C grep -q -m 1 $grep_case_insensitive_option -e "${key}\\&gt;" "$config_file"; then
    "${sed_command[@]}" "s/${key}\\&gt;.*/$formatted_output/g$sed_case_insensitive_option" "$config_file"
  else
    # \n is precaution for case where file ends without trailing newline
    printf '\n# Per %s: Set %s in %s\n' "$cce" "$formatted_output" "$config_file" &gt;&gt; "$config_file"
    printf '%s\n' "$formatted_output" &gt;&gt; "$config_file"
  fi
}</value>
    </Value>
    <Value hidden="true" id="function_set_faillock_option_to_value_in_pam_file" interactive="0" operator="equals" prohibitChanges="true" type="string">
      <title>Remediation function set_faillock_option_to_value_in_pam_file</title>
      <description>Shared bash remediation function. Not intended to be changed by tailoring.</description>
      <value selector="">function set_faillock_option_to_value_in_pam_file {
	# If invoked with no arguments, exit. This is an intentional behavior.
	[ $# -gt 1 ] || return 0
	[ $# -ge 3 ] || die "$0 requires exactly zero, three, or four arguments"
	[ $# -le 4 ] || die "$0 requires exactly zero, three, or four arguments"
	local _pamFile="$1" _option="$2" _value="$3" _insert_lines_callback="$4"
	# pam_faillock.so already present?
	if grep -q "^auth.*pam_faillock.so.*" "$_pamFile"; then

		# pam_faillock.so present, is the option present?
		if grep -q "^auth.*[default=die].*pam_faillock.so.*authfail.*$_option=" "$_pamFile"; then

			# both pam_faillock.so &amp; option present, just correct option to the right value
			sed -i --follow-symlinks "s/\(^auth.*required.*pam_faillock.so.*preauth.*silent.*\)\($_option *= *\).*/\1\2$_value/" "$_pamFile"
			sed -i --follow-symlinks "s/\(^auth.*[default=die].*pam_faillock.so.*authfail.*\)\($_option *= *\).*/\1\2$_value/" "$_pamFile"

		# pam_faillock.so present, but the option not yet
		else

			# append correct option value to appropriate places
			sed -i --follow-symlinks "/^auth.*required.*pam_faillock.so.*preauth.*silent.*/ s/$/ $_option=$_value/" "$_pamFile"
			sed -i --follow-symlinks "/^auth.*[default=die].*pam_faillock.so.*authfail.*/ s/$/ $_option=$_value/" "$_pamFile"
		fi

	# pam_faillock.so not present yet
	else
		test -z "$_insert_lines_callback" || "$_insert_lines_callback" "$_option" "$_value" "$_pamFile"
		# insert pam_faillock.so preauth &amp; authfail rows with proper value of the option in question
	fi
}</value>
    </Value>
  </Group>
  <Group id="chromium">
    <title>Chromium</title>
    <description>Chromium is an open-source web browser, powered by WebKit (Blink),
and developed by Google. Web browsers such as Chromium are used for a number of
reasons. This section provides settings for configuring Chromium policies to 
meet compliance settings for Chromium running on Red Hat Enterprise Linux 
systems.

Refer to <ul><li>https://www.chromium.org/administrators/policy-list-3</li></ul> for
a list of currently supported Chromium policies.
Refer to <ul><li>https://www.chromium.org/administrators/policy_templates</li></ul> for 
pre-created Chromium <tt>JSON</tt> policy files.</description>
    <Value id="var_url_blacklist" type="string">
      <title>Blacklisted Chromium Protocols</title>
      <description>Blacklisted Protocol Schemas in Chromium</description>
      <value>javascript://*</value>
      <value selector="javascript">javascript://*</value>
    </Value>
    <Value id="var_trusted_home_page" type="string">
      <title>Default Chromium Homepage</title>
      <description>Default homepage for Chromium users</description>
      <value>about:blank</value>
      <value selector="blank">about:blank</value>
    </Value>
    <Value id="var_extension_whitelist" type="string">
      <title>Whitelisted Chromium Extenstions</title>
      <description>Chromium extensions approved for use</description>
      <value>oiigbmnaadbkfbmpbfijlflahbdbdgdf</value>
      <value selector="none">oiigbmnaadbkfbmpbfijlflahbdbdgdf</value>
    </Value>
    <Value id="var_default_search_provider_name" type="string">
      <title>The Default Search provider in Chromium</title>
      <description>The URL for the Default Search provider in Chromium</description>
      <value>https://www.google.com</value>
      <value selector="bing">https://www.bing.com</value>
      <value selector="google">https://www.google.com</value>
      <value selector="yahoo">https://www.yahoo.com</value>
    </Value>
    <Value id="var_auth_schema" type="string">
      <title>Chromium HTTP Authentication Setting</title>
      <description>Chromium HTTP Authentication Types</description>
      <value selector="all">basic,digest,ntlm,negotiate</value>
      <value selector="basic">basic</value>
      <value>negotiate</value>
      <value selector="ntlm">ntlm</value>
      <value selector="negotiate">negotiate</value>
      <value selector="digest">digest</value>
    </Value>
    <Value id="var_enable_encrypted_searching" type="string">
      <title>Encrypted Chromium Search URLs</title>
      <description>Encrypted search URL for the Default Search Provider</description>
      <value>https://www.google.com/#q={searchTerms}</value>
      <value selector="bing">https://www.bing.com/search?q={searchTerms}</value>
      <value selector="google">https://www.google.com/#q={searchTerms}</value>
      <value selector="yahoo">https://www.yahoo.com/search?q={searchTerms}</value>
    </Value>
    <Rule id="chromium_disable_session_cookies" severity="unknown">
      <title>Disable Session Cookies</title>
      <description>To disable session only cookies sites, set <tt>CookiesSessionOnlyForUrls</tt>
to <tt>none</tt> in the Chromium policy file.</description>
      <rationale>Cookies should only be allowed per session and only for approved URLs as 
permanently stored cookies can be used for malicious intent.</rationale>
      <ref stigid="CHROMIUM-DTBC0045"/>
      <oval id="chromium_disable_session_cookies"/>
      <ocil clause="it is not disabled">To verify that sessions cookies for approved sites only are enabled,
run the following command:
<pre>$ grep CookiesSessionOnlyForUrls /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"CookiesSessionOnlyForUrls": ["none"],</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_search_suggestions" severity="unknown">
      <title>Disable Search Suggestion</title>
      <description>Chromium tries to guess what users are searching for when users enter
search data in the search Omnibox. This should be disabled by 
setting <tt>SearchSuggestEnabled</tt> to <tt>false</tt> in the Chromium 
policy file.</description>
      <rationale>Search suggestion should be disabled as it could lead to searches being conducted
that were never intended to be made.</rationale>
      <ref stigid="CHROMIUM-DTBC0027"/>
      <oval id="chromium_disable_search_suggestions"/>
      <ocil clause="it is not disabled">To verify that search suggestion is disabled, run the following command:
<pre>$ grep SearchSuggestEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"SearchSuggestEnabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_default_search_provider_name" severity="unknown">
      <title>Set the Default Search Provider's URL</title>
      <description>Specifies the URL of the default search provider that is to be used. To set the 
URL of the default search provider, set <tt>DefaultSearchProviderName</tt> to 
<tt><sub idref="var_default_search_provider"/></tt> in the Chromium policy file.</description>
      <rationale>When doing internet searches, it is important to set an organizationally approved search
provider as well as use an encrypted connection via https.</rationale>
      <ref stigid="CHROMIUM-DTBC0007"/>
      <oval id="chromium_default_search_provider_name"/>
      <ocil clause="a default search provider is not set">To verify that a default search provider is set, run the following command:
<pre>$ grep DefaultSearchProviderName /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DefaultSearchProviderName": "<sub idref="var_default_search_provider"/>",</pre></ocil>
    </Rule>
    <Rule id="chromium_enable_browser_history" severity="unknown">
      <title>Enable Saving the Browser History</title>
      <description>Users can enable or disable the saving of browser history in Chromium. Browser
history should be retained by setting <tt>SavingBrowserHistoryDisabled</tt> to
<tt>false</tt> in the Chromium policy file.</description>
      <rationale>Best practice requires that browser history is retained.</rationale>
      <ref stigid="CHROMIUM-DTBC0039"/>
      <oval id="chromium_enable_browser_history"/>
      <ocil clause="it is not enabled">To verify that saving the browser history is enabled, run the following command:
<pre>$ grep SavingBrowserHistoryDisabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"SavingBrowserHistoryDisabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_3d_graphics_api" severity="unknown">
      <title>Disable the 3D Graphics APIs</title>
      <description>Chromium uses WebGL to render graphics using the GPU which allows website
access to the GPU. This should be disabled by setting <tt>Disable3DAPIs</tt>
to <tt>true</tt> in the Chromium policy file.</description>
      <rationale>This setting prevents web pages from accessing the graphics processing unit
(GPU). Specifically, web pages cannot access the WebGL API and plugins cannot
use the Pepper 3D API in order to reduce the attack surface.</rationale>
      <ref stigid="CHROMIUM-DTBC0019"/>
      <oval id="chromium_disable_3d_graphics_api"/>
      <ocil clause="it is not disabled">To verify that 3D graphics are disabled, run the following command:
<pre>$ grep Disable3DAPIs /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"Disable3DAPIs": true,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_background_processing" severity="unknown">
      <title>Disable Background Processing</title>
      <description>Chromium can be set to run at all times and process in the background. This
should be disabled by setting <tt>BackgroundModeEnabled</tt> to <tt>false</tt>
in the Chromium policy file.</description>
      <rationale>There is two reasons that this is not wanted. First, it can tie up system
resources that might otherwise be needed. Second, it does not make it
obvious to the user that it is running and poorly written extensions could
cause instability on the system.</rationale>
      <ref stigid="CHROMIUM-DTBC0017"/>
      <oval id="chromium_disable_background_processing"/>
      <ocil clause="it is not disabled">To verify that background processing is disabled, run the following command:
<pre>$ grep BackgroundModeEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"BackgroundModeEnabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_plugin_blacklist" severity="unknown">
      <title>Disable All Plugins by Default</title>
      <description>Plugins are developed internally or by third party sources and are designed to extend
Google Chromium's functionality. All plugins should be blacklisted from 
installation by default. To blacklist all plugins set <tt>DisabledPlugins</tt>
to <tt>*</tt> in the Chromium policy file.</description>
      <rationale>Plugins can access almost anything on a system and users can enable or install them
at will. This means they pose a high risk to any system that would allow all plugins
to be installed by default.</rationale>
      <ref stigid="CHROMIUM-DTBC0034"/>
      <oval id="chromium_disable_plugin_blacklist"/>
      <ocil clause="they are not disabled">To verify that all plugins are blacklisted, run the following command:
<pre>$ grep DisabledPlugins /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DisabledPlugins": ["*"],</pre></ocil>
    </Rule>
    <Rule id="chromium_default_search_provider" severity="unknown">
      <title>Enable the Default Search Provider</title>
      <description>By default users, can change search provider settings. To disable this, set
<tt>DefaultSearchProviderEnabled</tt> to <tt>true</tt> in the Chromium policy file.</description>
      <rationale>A default search is performed when the user types text in the omnibox that is not a URL.
This should be organizationally defined and not allowed to be changed by a user.</rationale>
      <ref stigid="CHROMIUM-DTBC0009"/>
      <oval id="chromium_default_search_provider"/>
      <ocil clause="it is not enabled">To verify that users cannot change the default search provider, run the following command:
<pre>$ grep DefaultSearchProviderEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DefaultSearchProviderEnabled": true,</pre></ocil>
    </Rule>
    <Rule id="chromium_policy_file" severity="unknown">
      <title>Ensure the Chromium Policy Configuration File Exists</title>
      <description>Chromium can be configured with numerous policies and settings. These
settings can be set so that a user is unable to edit or change them.
To prevent users from setting or changing Chromium settings, a 
<tt>JavaScript Object Notation (JSON)</tt> file (contains the <tt>.json</tt>
extension) must exist in <tt>/etc/chromium/policies/managed</tt>.
<br/><br/>
<ul><li>Refer to https://www.chromium.org/administrators/policy-list-3 for
a list of currently supported Chromium policies.</li></ul>
<ul><li>Refer to https://www.chromium.org/administrators/policy_templates for
pre-created Chromium <tt>JSON</tt> policy files.</li></ul>
<br/></description>
      <rationale>The Chromium policy file must exist as this file contains configuration 
settings set by the System's Administrator to meet organization and/or 
security requirements.</rationale>
      <oval id="chromium_policy_file"/>
      <ocil clause="it does not exist or is not configured correctly">To verify that the Chromium policy file exists, run the following command:
<pre>$ ls /etc/chromium/policies/managed</pre>
The output should show file(s) ending in <tt>.json</tt> extension.
For example:
<pre>chrome-stig-policy.json</pre></ocil>
      <warning category="general">If the <tt>.json</tt> file in
<tt>/etc/chromium/policies/managed</tt> is not formatted correctly,
no policies will be configured or set correctly.</warning>
    </Rule>
    <Rule id="chromium_disable_automatic_installation" severity="unknown">
      <title>Disable Automatic Search And Installation of Plugins</title>
      <description>Chromium will automatically detect, search, and install plugins as required. This
should be disabled by setting <tt>DisablePluginFinder</tt> to <tt>true</tt> in the
Chromium policy file.</description>
      <rationale>The automatic search and installation of missing or not installed plugins should be
disabled as this can cause significant risk if a unapproved or vulnerable plugin were
to be installed without proper permissions or authorization.</rationale>
      <ref stigid="CHROMIUM-DTBC0036"/>
      <oval id="chromium_disable_automatic_installation"/>
      <ocil clause="it is not disabled">To verify that plugins cannot be automatically installed, run the following command:
<pre>$ grep DisablePluginFinder /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DisablePluginFinder": true,</pre></ocil>
    </Rule>
    <Rule id="chromium_enable_approved_plugins" severity="unknown">
      <title>Enable Only Approved Plugins</title>
      <description>An organization might need to use an internal or third party developed plugins. Any
organizationally approved plugin should be enabled. To enable approved plugins,
set <tt>EnabledPlugins</tt> to the list of organizationally approved plugins
in the Chromium policy file.</description>
      <rationale>The whitelist should only contain organizationally approved plugins. This is to prevent
a user from accidently whitelisitng a malicious plugin.</rationale>
      <ref stigid="CHROMIUM-DTBC0035"/>
      <oval id="chromium_enable_approved_plugins"/>
      <ocil clause="no plugins exist or it is not set to none">To verify that approved plugins are set, run the following command:
<pre>$ grep EnabledPlugins /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"EnabledPlugins": ["<tt>approved_plugin1</tt>", "<tt>approved_plugin2</tt>"],</pre></ocil>
    </Rule>
    <Rule id="chromium_disallow_location_tracking" severity="unknown">
      <title>Disable Location Tracking</title>
      <description>Location tracking is enabled by default and can track user's browsing habits.
Location tracking should be disabled by setting <tt>DefaultGeolocationSetting</tt> 
to <tt>2</tt> in the Chromium policy file.</description>
      <rationale>Website tracking is the practice of gathering information as to which websites
were accesses by a browser. The common method of doing this is to have a website
create a tracking cookie on the browser. If the information of what sites are
being accessed is made available to unauthorized persons, this violates 
confidentiality requirements, and over time poses a significant OPSEC issue.</rationale>
      <ref stigid="CHROMIUM-DTBC0002"/>
      <oval id="chromium_disallow_location_tracking"/>
      <ocil clause="it is not disabled">To verify that location tracking is disabled, run the following command:
<pre>$ grep DefaultGeolocationSetting /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DefaultGeolocationSetting": 2,</pre></ocil>
    </Rule>
    <Rule id="chromium_trusted_home_page" severity="unknown">
      <title>Set the Default Home Page</title>
      <description>When a browser is started the first web page displayed is the "home page".
While the home page can be selected by the user, the default home page needs
to be defined to display an approved page. To set the default home page,
set <tt>HomepageLocation</tt> to <tt><sub idref="var_trusted_home_page"/></tt>
in the Chromium policy file.</description>
      <rationale>If no home page is defined then there is a possibility that a URL to a malicious
site may be used as a home page which could effectively cause a denial of service
to the browser.</rationale>
      <ref stigid="CHROMIUM-DTBC0048"/>
      <oval id="chromium_trusted_home_page"/>
      <ocil clause="it is not set correctly">To verify that the defaut home page is set, run the following command:
<pre>$ grep HomepageLocation /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"HomepageLocation": "<sub idref="var_trusted_home_page"/>",</pre></ocil>
    </Rule>
    <Rule id="chromium_whitelist_plugin_urls" severity="unknown">
      <title>Enable Plugins for Only Approved URLs</title>
      <description>In some cases, plugins utilized by organizationally approved websites may be allowed
to be used by those websites, configure the approved URLs allowed to run plugins by
setting <tt>PluginsAllowedForUrls</tt> to organizationally approved URLs
in the Chromium policy file. If there are no approved URLs, this should be set
to <tt>none</tt></description>
      <rationale>Only approved plugins for approved sites should be allowed to be utilized.</rationale>
      <ref stigid="CHROMIUM-DTBC0051"/>
      <oval id="chromium_whitelist_plugin_urls"/>
      <ocil clause="no urls exist or it is not set to none">To verify that plugins are allowed for only approved URLs, 
run the following command:
<pre>$ grep PluginsAllowedForUrls /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"PluginsAllowedForUrls": ["[*.]mil", "[*.]example.com", "www.example.com"],</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_saved_passwords" severity="unknown">
      <title>Disable Saved Passwords</title>
      <description>Disable by setting <tt>ImportSavedPasswords</tt> to <tt>false</tt> in the Chromium
policy file.</description>
      <rationale>Importing of saved passwords should be disabled as it could lead to
unencrypted account passwords stored on the system from another browser
to be viewed.</rationale>
      <ref stigid="CHROMIUM-DTBC0029"/>
      <oval id="chromium_disable_saved_passwords"/>
      <ocil clause="it is not disabled">To verify that importing passwords is disabled, run the following command:
<pre>$ grep ImportSavedPasswords /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"ImportSavedPasswords": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_popups" severity="unknown">
      <title>Disable Popups</title>
      <description>Chromium allows you to manage whether or not unwanted pop-up windows appear.
To disable pop-ups, set <tt>DefaultPopupsSetting</tt> to <tt>2</tt> 
in the Chromium policy file.</description>
      <rationale>Pop-up windows should be disabled to prevent malicious websites from controlling
pop-up windows or fooling users into clicking on the wrong window.</rationale>
      <ref stigid="CHROMIUM-DTBC0004"/>
      <oval id="chromium_disable_popups"/>
      <ocil clause="it is not disabled">To verify that pop-ups are disabled, run the following command:
<pre>$ grep DefaultPopupsSetting /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DefaultPopupsSetting": 2,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_incognito_mode" severity="unknown">
      <title>Disable Incognito Mode</title>
      <description>Incognito Mode allows users to browse in private which prevents monitoring
and validating user browsing habits. This capability should be disabled by
setting <tt>IncognitoModeAvailability</tt> to <tt>1</tt> in the Chromium
policy file.</description>
      <rationale>Incognito mode allows the user to browse the Internet without recording their
browsing history/activity. From a forensics perspective, this is unacceptable.
Best practice requires that browser history is retained.</rationale>
      <ref stigid="CHROMIUM-DTBC0030"/>
      <oval id="chromium_disable_incognito_mode"/>
      <ocil clause="it is not disabled">To verify that incognito mode is disabled, run the following command:
<pre>$ grep IncognitoModeAvailability /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"IncognitoModeAvailability": 1,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_firewall_traversal" severity="unknown">
      <title>Disable Chromium's Ability to Traverse Firewalls</title>
      <description>Chromium has the ability to bypass and ignore the system firewall. This
ability should be disabled. To disable this setting, set 
<tt>RemoteAccessHostFirewallTraversal</tt> to <tt>false</tt> in the 
Chromium policy file.</description>
      <rationale>Remote connections should never be allowed to bypass the system firewall
as there is no way to verify if they can be trusted.</rationale>
      <ref stigid="CHROMIUM-DTBC0001"/>
      <oval id="chromium_disable_firewall_traversal"/>
      <ocil clause="it is not disabled">To verify that Chromium's abililty to traverse the system firewall is 
disabled, run the following command:
<pre>$ grep RemoteAccessHostFirewallTraversal /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"RemoteAccessHostFirewallTraversal": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_http_authentication" severity="unknown">
      <title>Set Chromium's HTTP Authentication Scheme</title>
      <description>To set the default Chromium's HTTP Authentication Scheme, set 
<tt>AuthSchemes</tt> to <tt><sub idref="var_auth_schemes"/></tt> in the 
Chromium policy file.</description>
      <rationale>Specifies which HTTP Authentication schemes are supported by Google Chromium.</rationale>
      <ref stigid="CHROMIUM-DTBC0012"/>
      <oval id="chromium_http_authentication"/>
      <ocil clause="it is not set">To verify that the HTTP Authentication Scheme is set, run the following command:
<pre>$ grep AuthSchemes /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"AuthSchemes": "<sub idref="var_auth_schemes"/>",</pre></ocil>
    </Rule>
    <Rule id="chromium_default_block_plugins" severity="unknown">
      <title>Block Plugins by Default</title>
      <description>By default, websites are allowed to automatically run plugins.
Users should be prompted to allow plugins to execute plugins by setting
<tt>DefaultPluginsSetting</tt> to <tt>3</tt> in the Chromium policy file.</description>
      <rationale>Websites should not be allowed to automatically run plugins as the plugins
may be outdated or compromised.</rationale>
      <ref stigid="CHROMIUM-DTBC0040"/>
      <oval id="chromium_default_block_plugins"/>
      <ocil clause="it is not set correctly">To verify that plugins cannot run automatically, run the following command:
<pre>$ grep DefaultPluginsSetting /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DefaultPluginsSetting": 3,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_cleartext_passwords" severity="unknown">
      <title>Disable Use of Cleartext Passwords</title>
      <description>Chromium allows users to import and store passwords in cleartext. This should be 
disabled by setting <tt>PasswordManagerAllowShowPasswords</tt> to <tt>false</tt>
in the Chromium policy file.</description>
      <rationale>Cleartext passwords would allow another individual to see password via shoulder surfing.</rationale>
      <ref stigid="CHROMIUM-DTBC0010"/>
      <oval id="chromium_disable_cleartext_passwords"/>
      <ocil clause="use of cleartext passwords are not disabled">To verify that the use of cleartext passwords is disabled, run the following command:
<pre>$ grep PasswordManagerAllowShowPasswords /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"PasswordManagerAllowShowPasswords": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_enable_safe_browsing" severity="unknown">
      <title>Enable the Safe Browsing Feature</title>
      <description>Chromium has the capability to check URLs for known malware and phishing 
associated with websites through the Safe Browsing Feature. This can be 
enabled by setting <tt>SafeBrowsingEnabled</tt> to <tt>true</tt> in the Chromium
policy file.</description>
      <rationale>Safe browsing uses a signature database to test sites when they are be loaded
to ensure that sites do not contain any known malware.</rationale>
      <ref stigid="CHROMIUM-DTBC0038"/>
      <oval id="chromium_enable_safe_browsing"/>
      <ocil clause="it is not enabled">To verify that the safe browsing feature is enabled, run the following command:
<pre>$ grep SafeBrowsingEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"SafeBrowsingEnabled": true,</pre></ocil>
    </Rule>
    <Rule id="chromium_enable_encrypted_searching" severity="unknown">
      <title>Enable Encrypted Searching</title>
      <description>Specifies the URL of the search engine used when doing a default search.
The URL should contain the string <tt>{searchTerms}</tt>. To set the URL of the
search engine, set <tt>DefaultSearchProviderSearchURL</tt> to
<tt><sub idref="var_enable_encrypted_searching"/></tt> in the Chromium policy file.</description>
      <rationale>When doing internet searches, it is important to use an encrypted connection via https.</rationale>
      <ref stigid="CHROMIUM-DTBC0008"/>
      <oval id="chromium_enable_encrypted_searching"/>
      <ocil clause="it is not set">To verify that the URL of the search engine is set, run the following command:
<pre>$ grep DefaultSearchProviderSearchURL /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DefaultSearchProviderSearchURL": "<sub idref="var_enable_encrypted_searching"/>",</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_outdated_plugins" severity="unknown">
      <title>Disable Outdated Plugins</title>
      <description>Outdated plugins should be disabled by setting <tt>AllowOutdatedPlugins</tt>
to <tt>false</tt> in the Chromium policy file.</description>
      <rationale>Running outdated plugins could lead to system compromise through the use
of known exploits. Having plugins updated to the most current version
ensures the smallest attack surfuce possible.</rationale>
      <ref stigid="CHROMIUM-DTBC0013"/>
      <oval id="chromium_disable_outdated_plugins"/>
      <ocil clause="it is not disabled">To verify that outdated plugins are disabled, run the following command:
<pre>$ grep AllowOutdatedPlugins /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"AllowOutdatedPlugins": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_extension_whitelist" severity="unknown">
      <title>Enable Only Approved Extensions</title>
      <description>An organization might need to use an internal or third party developed extension. Any
organizationally approved extenstion should be enabled. To enable approved extensions,
set <tt>ExtensionInstallWhitelist</tt> to <tt><sub idref="var_extension_whitelist"/></tt>
in the Chromium policy file.
If there are no approved extensions, <tt>ExtensionInstallWhitelist</tt> should be set to
<tt><sub idref="var_extension_whitelist" selector="default"/></tt>.</description>
      <rationale>The whitelist should only contain organizationally approved extensions. This is to prevent
a user from accidently whitelisitng a malicious extension.</rationale>
      <ref stigid="CHROMIUM-DTBC0003"/>
      <oval id="chromium_extension_whitelist"/>
      <ocil clause="approved extensions are not set">To verify that approved extensions are whitelisted, run the following command:
<pre>$ grep ExtensionInstallWhitelist /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"ExtensionInstallWhitelist": ["<sub idref="var_extension_whitelist"/>"],</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_autocomplete" severity="unknown">
      <title>Disable the AutoFill Feature</title>
      <description>The AutoFill feature suggests possible matches when users are filling in forms. To
disable the AutoFill feature, set <tt>AutoFillEnabled</tt> to <tt>false</tt> in
the Chromium policy file.</description>
      <rationale>It is possible with the AutoFill feature that it will cache sensitive data and store
it in the user's profile, where it might not be protected as rigorously as required by
organizational policy.</rationale>
      <ref stigid="CHROMIUM-DTBC0022"/>
      <oval id="chromium_disable_autocomplete"/>
      <ocil clause="it is not disabled">To verify that the AutoFill feature is disabled, run the following command:
<pre>$ grep AutoFillEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"AutoFillEnabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_check_cert_revocation" severity="unknown">
      <title>Enable Online OCSP/CRL Certificate Checks</title>
      <description>Certificates can become compromised, and Chromium should check that the
certificates in its store are valid by setting <tt>EnableOnlineRevocationChecks</tt>
to <tt>true</tt> in the Chromium policy file.</description>
      <rationale>Certificates are revoked when they have been compromised or are no longer valid,
and this option protects users from submitting confidential data to a site that
may be fraudulent or not secure.</rationale>
      <ref stigid="CHROMIUM-DTBC0037"/>
      <oval id="chromium_check_cert_revocation"/>
      <ocil clause="it is not enabled">To verify that online OCSP/CRL checks are enabled, run the following command:
<pre>$ grep EnableOnlineRevocationChecks /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"EnableOnlineRevocationChecks": true,</pre></ocil>
    </Rule>
    <Rule id="chromium_block_desktop_notifications" severity="unknown">
      <title>Prevent Desktop Notifications</title>
      <description>Chromium by default allows websites to display notifications on the desktop.
To disable this setting, set <tt>DefaultNotificationsSetting</tt> to <tt>2</tt>
in the Chromium policy file.</description>
      <rationale>Disabling Chromium's ability to display notifications on the desktop helps prevent 
malicious websites from controlling desktop notifications or fooling users into
clicking on a potentially compromised notification.</rationale>
      <ref stigid="CHROMIUM-DTBC0003"/>
      <oval id="chromium_block_desktop_notifications"/>
      <ocil clause="it is not disabled">To verify that desktop notification is
disabled, run the following command:
<pre>$ grep DefaultNotificationsSetting /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DefaultNotificationsSetting": 2,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_google_sync" severity="unknown">
      <title>Disable Data Synchronization to Google</title>
      <description><tt>SyncDisabled</tt> to <tt>true</tt> in the Chromium policy file.</description>
      <rationale>Google Sync is used to sync information between different user devices,
this data is then stored on Google owned servers. The synced data may consist
of information such as email, calendars, viewing history, etc. This feature must
be disabled because the organization does not have control over the servers the
data is stored on.</rationale>
      <ref stigid="CHROMIUM-DTBC0020"/>
      <oval id="chromium_disable_google_sync"/>
      <ocil clause="it is not disabled">To verify that data synchronization is disabled, run the following command:
<pre>$ grep SyncDisabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"SyncDisabled": true,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_thirdparty_cookies" severity="unknown">
      <title>Disable 3rd Party Cookies</title>
      <description>Third party cookies should be be enabled. To disable third party cookies,
set <tt>BlockThirdPartyCookies</tt> to <tt>true</tt> in the Chromium policy
file.</description>
      <rationale>Third party cookies are cookies which can be set by web page elements that
are not from the domain that is in the browser's address bar. This prevents
cookies from being set by web page elements that are not from the domain
that is in the browser's address bar.</rationale>
      <ref stigid="CHROMIUM-DTBC0015"/>
      <oval id="chromium_disable_thirdparty_cookies"/>
      <ocil clause="it is not disabled">To verify that third party cookies are disabled, run the following command:
<pre>$ grep BlockThirdPartyCookies /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"BlockThirdPartyCookies": true,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_metrics_reporting" severity="unknown">
      <title>Disable Metrics Reporting</title>
      <description>Whenever Chromium crashes, it sends its usage and crash-related data to Google.
This should be disabled by setting <tt>MetricsReportingEnabled</tt> to 
<tt>false</tt> in the Chromium policy file.</description>
      <rationale>Anonymous reporting of usage and crash-related data is sent to Google.
A crash report could contain sensitive information from the computer's memory.</rationale>
      <ref stigid="CHROMIUM-DTBC0026"/>
      <oval id="chromium_disable_metrics_reporting"/>
      <ocil clause="it is not disabled">To verify that metrics reporting is disabled, run the following command:
<pre>$ grep MetricsReportingEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"MetricsReportingEnabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_protocol_schemas" severity="unknown">
      <title>Disable Insecure And Obsolete Protocol Schemas</title>
      <description>Each access to a URL is handled by the browser according to the URL's "scheme".
The "scheme" of a URL is the section before the ":". The term "protocol" is often
mistakenly used for a "scheme". The difference is that the scheme is how the browser
handles a URL and the protocol is how the browser communicates with a service. To
disable insecure and obsolete protocol schema, set <tt>URLBlacklist</tt> to
<tt><sub idref="var_url_blacklist"/></tt> in the Chromium policy file.</description>
      <rationale>If a scheme or its associated protocol used by a browser is insecure or obsolete,
vulnerabilities can be exploited resulting in exposed data or unrestricted access
to the browser's system.</rationale>
      <ref stigid="CHROMIUM-DTBC0021"/>
      <oval id="chromium_disable_protocol_schemas"/>
      <ocil clause="it is not disabled">To verify that data synchronization is disabled, run the following command:
<pre>$ grep URLBlacklist /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"URLBlacklist": ["<sub idref="var_url_blacklist"/>"],</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_password_manager" severity="unknown">
      <title>Disable Chromium Password Manager</title>
      <description>Chromium Password Manager allows the saving and using of passwords in Chromium. This
should be disabled by setting <tt>PasswordManagerEnabled</tt> to <tt>false</tt> in 
the Chromium policy file.</description>
      <rationale>Enables saving passwords and using saved passwords in Google Chromium. Malicious
sites may take advantage of this feature by using hidden fields gain access
to the stored information.</rationale>
      <ref stigid="CHROMIUM-DTBC0011"/>
      <oval id="chromium_disable_password_manager"/>
      <ocil clause="it is not disabled">To verify that the use of Password Manager is disabled, run the following command:
<pre>$ grep PasswordManagerEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"PasswordManagerEnabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_blacklist_extension_installation" severity="unknown">
      <title>Disable All Extensions by Default</title>
      <description>Extensions are developed by third party sources and are designed to extend 
Google Chromium's functionality. As an extension can be made by anyone, all extensions
should be blacklisted from installation by default. To blacklist all extensions, set the 
<tt>ExtensionInstallBlacklist</tt> to <tt>*</tt> in the Chromium policy file.</description>
      <rationale>Extensions can access almost anything on a system. This means they pose a high risk
to any system that would allow all extensions to be installed by default.</rationale>
      <ref stigid="CHROMIUM-DTBC0006"/>
      <oval id="chromium_blacklist_extension_installation"/>
      <ocil clause="extensions are not blacklisted">To verify that all extensions are blacklisted from installing, run the following command:
<pre>$ grep ExtensionInstallBlacklist /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"ExtensionInstallBlacklist": ["*"],</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_network_prediction" severity="unknown">
      <title>Disable Network Prediction</title>
      <description>To disable the network prediction feature, set <tt>DnsPrefetchingEnabled</tt>
to <tt>false</tt> in the Chromium policy file.</description>
      <rationale>This controls not only DNS prefetching but also TCP and SSL preconnection
and prerendering of web pages.</rationale>
      <ref stigid="CHROMIUM-DTBC0025"/>
      <oval id="chromium_disable_network_prediction"/>
      <ocil clause="it is not disabled">To verify that network prediction is disabled, run the following command:
<pre>$ grep DnsPrefetchingEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"DnsPrefetchingEnabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_disable_cloud_print_sharing" severity="unknown">
      <title>Disable Cloud Print Sharing</title>
      <description>Chromium has cloud sharing capabilities including sharing printers connected to the
system. This is done via a proxy. To disable printer sharing, set <tt>CloudPrintProxyEnabled</tt>
to <tt>false</tt> in the Chromium policy file.</description>
      <rationale>Google Chromium has the capability to act as a proxy between Google Cloud Print
and legacy printers connected to the machine. Users can then enable the cloud
print proxy by authentication with their Google account.</rationale>
      <ref stigid="CHROMIUM-DTBC0023"/>
      <oval id="chromium_disable_cloud_print_sharing"/>
      <ocil clause="it is not disabled">To verify that the Cloud Print Sharing feature is disabled, run the following command:
<pre>$ grep CloudPrintProxyEnabled /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"CloudPrintProxyEnabled": false,</pre></ocil>
    </Rule>
    <Rule id="chromium_plugins_require_authorization" severity="unknown">
      <title>Require Outdated Plugins to be Authorized</title>
      <description>Chromium should prompt users for authorization to run outdated plugins. This
can be enabled by setting <tt>AlwaysAuthorizePlugins</tt> to <tt>false</tt>
in the Chromium policy file.</description>
      <rationale>Outdated plugins can compromise security and should request authorization from
the user before running.</rationale>
      <ref stigid="CHROMIUM-DTBC0014"/>
      <oval id="chromium_plugins_require_authorization"/>
      <ocil clause="it is not set">To verify that plugins require authorization to run, run the following command:
<pre>$ grep AlwaysAuthorizePlugins /etc/chromium/policies/managed/*.json</pre>
The output should contain:
<pre>"AlwaysAuthorizePlugins": false,</pre></ocil>
    </Rule>
  </Group>
</Benchmark>
